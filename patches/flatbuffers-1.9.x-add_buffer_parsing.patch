diff --git a/include/flatbuffers/code_generators.h b/include/flatbuffers/code_generators.h
index d19002e..bd16439 100644
--- a/include/flatbuffers/code_generators.h
+++ b/include/flatbuffers/code_generators.h
@@ -70,6 +70,7 @@ class CodeWriter {
 class BaseGenerator {
  public:
   virtual bool generate() = 0;
+  virtual std::string generateCode();
 
   static std::string NamespaceDir(const Parser &parser, const std::string &path,
                                   const Namespace &ns);
diff --git a/include/flatbuffers/idl.h b/include/flatbuffers/idl.h
index a811fcb..d9fc21c 100644
--- a/include/flatbuffers/idl.h
+++ b/include/flatbuffers/idl.h
@@ -451,12 +451,15 @@ struct IDLOptions {
 
 // This encapsulates where the parser is in the current source file.
 struct ParserState {
-  ParserState() : cursor_(nullptr), line_(1), token_(-1) {}
+  ParserState() : cursor_(nullptr), line_(1), token_(-1), has_size_(false), len_(0), eof_(nullptr) {}
 
  protected:
   const char *cursor_;
   int line_;  // the current line being parsed
   int token_;
+  bool has_size_;
+  unsigned int len_;
+  const char *eof_;
 
   std::string attribute_;
   std::vector<std::string> doc_comment_;
@@ -565,6 +568,9 @@ class Parser : public ParserState {
   bool Parse(const char *_source, const char **include_paths = nullptr,
              const char *source_filename = nullptr);
 
+  // Set the maximum size to process.
+  void SetSize(const bool has_size, const unsigned int len);
+
   // Set the root type. May override the one set in the schema.
   bool SetRootType(const char *name);
 
@@ -762,6 +768,10 @@ extern bool GenerateCPP(const Parser &parser,
                         const std::string &path,
                         const std::string &file_name);
 
+// Generate JavaScript or TypeScript code from the definitions in the Parser object.
+// See idl_gen_js.
+extern std::string GenerateJSCode(const Parser &parser);
+
 // Generate JavaScript or TypeScript code from the definitions in the Parser object.
 // See idl_gen_js.
 extern bool GenerateJS(const Parser &parser,
diff --git a/src/code_generators.cpp b/src/code_generators.cpp
index c6bf91c..b9ee84e 100644
--- a/src/code_generators.cpp
+++ b/src/code_generators.cpp
@@ -67,6 +67,10 @@ const char *BaseGenerator::FlatBuffersGeneratedWarning() {
          " do not modify";
 }
 
+std::string BaseGenerator::generateCode() {
+    return NULL;
+}
+
 std::string BaseGenerator::NamespaceDir(const Parser &parser,
                                         const std::string &path,
                                         const Namespace &ns) {
diff --git a/src/idl_gen_js.cpp b/src/idl_gen_js.cpp
index c0844d4..c8a45cd 100644
--- a/src/idl_gen_js.cpp
+++ b/src/idl_gen_js.cpp
@@ -80,7 +80,7 @@ class JsGenerator : public BaseGenerator {
         lang_(GetJsLangParams(parser_.opts.lang)){};
   // Iterate through all definitions we haven't generate code for (enums,
   // structs, and tables) and output them to a single file.
-  bool generate() {
+  std::string generateCode() {
     imported_fileset imported_files;
     reexport_map reexports;
 
@@ -106,7 +106,11 @@ class JsGenerator : public BaseGenerator {
       code += "// Exports for Node.js and RequireJS\n";
       code += exports_code;
     }
+    return code;
+  }
 
+  bool generate() {
+    std::string code = generateCode();
     return SaveFile(GeneratedFileName(path_, file_name_, lang_).c_str(), code,
                     false);
   }
@@ -1173,6 +1177,11 @@ class JsGenerator : public BaseGenerator {
 };
 }  // namespace js
 
+std::string GenerateJSCode(const Parser &parser) {
+    js::JsGenerator generator(parser, "", "");
+    return generator.generateCode();
+}
+
 bool GenerateJS(const Parser &parser, const std::string &path,
                 const std::string &file_name) {
   js::JsGenerator generator(parser, path, file_name);
diff --git a/src/idl_parser.cpp b/src/idl_parser.cpp
index b16e3e1..567ce41 100644
--- a/src/idl_parser.cpp
+++ b/src/idl_parser.cpp
@@ -262,6 +262,10 @@ CheckedError Parser::Next() {
   bool seen_newline = false;
   attribute_.clear();
   for (;;) {
+    if (has_size_ && cursor_ >= eof_) {
+      token_ = kTokenEof;
+      return NoError();
+    }
     char c = *cursor_++;
     token_ = c;
     switch (c) {
@@ -1748,6 +1752,11 @@ CheckedError Parser::ParseService() {
   return NoError();
 }
 
+void Parser::SetSize(const bool has_size, const unsigned int len) {
+  has_size_ = has_size;
+  len_ = len;
+}
+
 bool Parser::SetRootType(const char *name) {
   root_struct_def_ = LookupStruct(name);
   if (!root_struct_def_)
@@ -2235,6 +2244,9 @@ CheckedError Parser::StartParseFile(const char *source,
   file_being_parsed_ = source_filename ? source_filename : "";
   source_ = cursor_ = source;
   line_ = 1;
+  if (has_size_) {
+    eof_ = source + len_;
+  }
   error_.clear();
   ECHECK(SkipByteOrderMark());
   NEXT();
@@ -2374,6 +2386,8 @@ CheckedError Parser::DoParse(const char *source, const char **include_paths,
         std::string contents;
         if (!LoadFile(filepath.c_str(), true, &contents))
           return Error("unable to load include file: " + name);
+        bool has_size = has_size_;
+        has_size_ = false;
         ECHECK(DoParse(contents.c_str(), include_paths, filepath.c_str(),
                        name.c_str()));
         // We generally do not want to output code for any included files:
@@ -2383,6 +2397,7 @@ CheckedError Parser::DoParse(const char *source, const char **include_paths,
         root_struct_def_ = nullptr;
         file_identifier_.clear();
         file_extension_.clear();
+        has_size_ = has_size;
         // This is the easiest way to continue this file after an include:
         // instead of saving and restoring all the state, we simply start the
         // file anew. This will cause it to encounter the same include
