diff --git a/include/flatbuffers/code_generators.h b/include/flatbuffers/code_generators.h
index d19002e..bd16439 100644
--- a/include/flatbuffers/code_generators.h
+++ b/include/flatbuffers/code_generators.h
@@ -70,6 +70,7 @@ class CodeWriter {
 class BaseGenerator {
  public:
   virtual bool generate() = 0;
+  virtual std::string generateCode();
 
   static std::string NamespaceDir(const Parser &parser, const std::string &path,
                                   const Namespace &ns);
diff --git a/include/flatbuffers/idl.h b/include/flatbuffers/idl.h
index a811fcb..d9fc21c 100644
--- a/include/flatbuffers/idl.h
+++ b/include/flatbuffers/idl.h
@@ -478,7 +478,7 @@
 // This encapsulates where the parser is in the current source file.
 struct ParserState {
   ParserState()
-      : cursor_(nullptr), line_start_(nullptr), line_(0), token_(-1) {}
+      : cursor_(nullptr), line_start_(nullptr), line_(0), token_(-1), has_length_(false), len_(0), eof_(nullptr) {}
 
  protected:
   void ResetState(const char *source) {
@@ -501,6 +501,9 @@
   const char *line_start_;
   int line_;  // the current line being parsed
   int token_;
+  bool has_length_;
+  unsigned int len_;
+  const char *eof_;
 
   std::string attribute_;
   std::vector<std::string> doc_comment_;
@@ -613,6 +616,9 @@
   // paths from user input, please call PosixPath on them first.
   bool Parse(const char *_source, const char **include_paths = nullptr,
              const char *source_filename = nullptr);
+
+  // Set the maximum size to process.
+  void SetContentLength(const bool has_length, const unsigned int len);
 
   // Set the root type. May override the one set in the schema.
   bool SetRootType(const char *name);
@@ -827,6 +833,10 @@
 
 // Generate JavaScript or TypeScript code from the definitions in the Parser object.
 // See idl_gen_js.
+extern std::string GenerateJSCode(const Parser &parser);
+
+// Generate JavaScript or TypeScript code from the definitions in the Parser object.
+// See idl_gen_js.
 extern bool GenerateJS(const Parser &parser,
                        const std::string &path,
                        const std::string &file_name);
diff --git a/include/flatbuffers/util.h b/include/flatbuffers/util.h
index e654010..d8a3bd7 100644
--- a/include/flatbuffers/util.h
+++ b/include/flatbuffers/util.h
@@ -89,9 +89,7 @@
 template<typename T> std::string NumToString(T t) {
   // clang-format off
   #ifndef FLATBUFFERS_PREFER_PRINTF
-    std::stringstream ss;
-    ss << t;
-    return ss.str();
+    return std::to_string(t);
   #else // FLATBUFFERS_PREFER_PRINTF
     auto v = static_cast<long long>(t);
     return NumToStringImplWrapper(v, "%.*lld");
diff --git a/src/code_generators.cpp b/src/code_generators.cpp
index c6bf91c..b9ee84e 100644
--- a/src/code_generators.cpp
+++ b/src/code_generators.cpp
@@ -67,6 +67,10 @@ const char *BaseGenerator::FlatBuffersGeneratedWarning() {
          " do not modify";
 }
 
+std::string BaseGenerator::generateCode() {
+    return NULL;
+}
+
 std::string BaseGenerator::NamespaceDir(const Parser &parser,
                                         const std::string &path,
                                         const Namespace &ns) {
diff --git a/src/idl_gen_js.cpp b/src/idl_gen_js.cpp
index c0844d4..c8a45cd 100644
--- a/src/idl_gen_js.cpp
+++ b/src/idl_gen_js.cpp
@@ -82,7 +82,7 @@
         lang_(GetJsLangParams(parser_.opts.lang)){};
   // Iterate through all definitions we haven't generate code for (enums,
   // structs, and tables) and output them to a single file.
-  bool generate() {
+  std::string generateCode() {
     imported_fileset imported_files;
     reexport_map reexports;
 
@@ -112,6 +112,11 @@
       code += exports_code;
     }
 
+    return code;
+  }
+ 
+  bool generate() {
+    std::string code = generateCode();
     return SaveFile(GeneratedFileName(path_, file_name_, lang_).c_str(), code,
                     false);
   }
@@ -1249,6 +1254,11 @@
 };
 }  // namespace js
 
+std::string GenerateJSCode(const Parser &parser) {
+    js::JsGenerator generator(parser, "", "");
+    return generator.generateCode();
+}
+
 bool GenerateJS(const Parser &parser, const std::string &path,
                 const std::string &file_name) {
   js::JsGenerator generator(parser, path, file_name);
diff --git a/src/idl_parser.cpp b/src/idl_parser.cpp
index b16e3e1..567ce41 100644
--- a/src/idl_parser.cpp
+++ b/src/idl_parser.cpp
@@ -270,6 +270,10 @@
   bool seen_newline = cursor_ == source_;
   attribute_.clear();
   for (;;) {
+    if (has_length_ && cursor_ >= eof_) {
+      token_ = kTokenEof;
+      return NoError();
+    }
     char c = *cursor_++;
     token_ = c;
     switch (c) {
@@ -1770,6 +1774,11 @@
   return NoError();
 }
 
+void Parser::SetContentLength(const bool has_length, const unsigned int len) {
+  has_length_ = has_length;
+  len_ = len;
+}
+
 bool Parser::SetRootType(const char *name) {
   root_struct_def_ = LookupStruct(name);
   if (!root_struct_def_)
@@ -2262,6 +2271,9 @@
   file_being_parsed_ = source_filename ? source_filename : "";
   source_ = source;
   ResetState(source_);
+  if (has_length_) {
+    eof_ = source + len_;
+  }
   error_.clear();
   ECHECK(SkipByteOrderMark());
   NEXT();
@@ -2401,6 +2413,8 @@
         std::string contents;
         if (!LoadFile(filepath.c_str(), true, &contents))
           return Error("unable to load include file: " + name);
+        bool has_length = has_length_;
+        has_length_ = false;
         ECHECK(DoParse(contents.c_str(), include_paths, filepath.c_str(),
                        name.c_str()));
         // We generally do not want to output code for any included files:
@@ -2410,6 +2424,7 @@
         root_struct_def_ = nullptr;
         file_identifier_.clear();
         file_extension_.clear();
+        has_length_ = has_length;
         // This is the easiest way to continue this file after an include:
         // instead of saving and restoring all the state, we simply start the
         // file anew. This will cause it to encounter the same include
