/* eslint-env node, mocha */
/* eslint-disable no-magic-numbers, default-case, no-var */

const {assert} = require("chai");
const {flatbuffers} = require("flatbuffers");
const addon = require("../");
const fs = require("fs");
const sysPath = require("path");

describe("flatbuffers", () => {
    const workDir = sysPath.resolve(__dirname, "fbs");

    const schema = sysPath.join(workDir, "monster_test.fbs");
    const schema_contents = fs.readFileSync(schema);
    const include_directories = [sysPath.join(workDir, "include")];

    const MyGame = (new Function(`${ addon.js({ // eslint-disable-line no-new-func
        schema,
        schema_contents,
        schema_length: schema_contents.length,
        include_directories,
        mutable_buffer: true,
        skip_flatbuffers_import: true,
    }) } return MyGame`)).call({});

    it("should generate valid js/binary", () => {
        const json = sysPath.join(workDir, "monsterdata_test.json");
        const json_contents = fs.readFileSync(json);

        // First, let's test reading a FlatBuffer generated by C++ code:
        // This file was generated from monsterdata_test.json
        const data = new Uint8Array(addon.binary({
            schema,
            schema_contents,
            schema_length: schema_contents.length,
            json,
            json_contents,
            json_length: json_contents.length,
            include_directories
        }));

        // Now test it:

        const bb = new flatbuffers.ByteBuffer(data);
        testBuffer(bb);

        // Second, let's create a FlatBuffer from scratch in JavaScript, and test it also.
        // We use an initial size of 1 to exercise the reallocation algorithm,
        // normally a size larger than the typical FlatBuffer you generate would be
        // better for performance.
        const fbb = new flatbuffers.Builder(1);
        createMonster(fbb);
        serializeAndTest(fbb);

        // clear the builder, repeat tests
        const clearIterations = 100;
        const startingCapacity = fbb.bb.capacity();
        for (let i = 0; i < clearIterations; i++) {
            fbb.clear();
            createMonster(fbb);
            serializeAndTest(fbb);
        }
        // the capacity of our buffer shouldn't increase with the same size payload
        assert.strictEqual(fbb.bb.capacity(), startingCapacity);

        test64bit();
        testUnicode();
        fuzzTest1();
    });


    function createMonster(fbb) {
        // We set up the same values as monsterdata.json:

        const str = fbb.createString("MyMonster");

        const inv = MyGame.Example.Monster.createInventoryVector(fbb, [0, 1, 2, 3, 4]);

        const fred = fbb.createString("Fred");
        MyGame.Example.Monster.startMonster(fbb);
        MyGame.Example.Monster.addName(fbb, fred);
        const mon2 = MyGame.Example.Monster.endMonster(fbb);

        MyGame.Example.Monster.startTest4Vector(fbb, 2);
        MyGame.Example.Test.createTest(fbb, 10, 20);
        MyGame.Example.Test.createTest(fbb, 30, 40);
        const test4 = fbb.endVector();

        const testArrayOfString = MyGame.Example.Monster.createTestarrayofstringVector(fbb, [
            fbb.createString("test1"),
            fbb.createString("test2")
        ]);

        MyGame.Example.Monster.startMonster(fbb);
        MyGame.Example.Monster.addPos(fbb, MyGame.Example.Vec3.createVec3(fbb, 1, 2, 3, 3, MyGame.Example.Color.Green, 5, 6));
        MyGame.Example.Monster.addHp(fbb, 80);
        MyGame.Example.Monster.addName(fbb, str);
        MyGame.Example.Monster.addInventory(fbb, inv);
        MyGame.Example.Monster.addTestType(fbb, MyGame.Example.Any.Monster);
        MyGame.Example.Monster.addTest(fbb, mon2);
        MyGame.Example.Monster.addTest4(fbb, test4);
        MyGame.Example.Monster.addTestarrayofstring(fbb, testArrayOfString);
        MyGame.Example.Monster.addTestbool(fbb, true);
        const mon = MyGame.Example.Monster.endMonster(fbb);

        MyGame.Example.Monster.finishMonsterBuffer(fbb, mon);
    }

    function serializeAndTest(fbb) {
        // Write the result to a file for debugging purposes:
        // Note that the binaries are not necessarily identical, since the JSON
        // parser may serialize in a slightly different order than the above
        // JavaScript code. They are functionally equivalent though.

        // fs.writeFileSync("monsterdata_javascript_wire.mon", Buffer.from(fbb.asUint8Array()));

        // Tests mutation first.  This will verify that we did not trample any other
        // part of the byte buffer.
        testMutation(fbb.dataBuffer());

        testBuffer(fbb.dataBuffer());
    }

    function testMutation(bb) {
        const monster = MyGame.Example.Monster.getRootAsMonster(bb);

        monster.mutate_hp(120);
        assert.strictEqual(monster.hp(), 120);

        monster.mutate_hp(80);
        assert.strictEqual(monster.hp(), 80);

        const manaRes = monster.mutate_mana(10);
        assert.strictEqual(manaRes, false); // Field was NOT present, because default value.

        // TODO: There is not the availability to mutate structs or vectors.
    }

    function testBuffer(bb) {
        assert.ok(MyGame.Example.Monster.bufferHasIdentifier(bb));

        const monster = MyGame.Example.Monster.getRootAsMonster(bb);

        assert.strictEqual(monster.hp(), 80);
        assert.strictEqual(monster.mana(), 150); // default

        assert.strictEqual(monster.name(), "MyMonster");

        const pos = monster.pos();
        assert.strictEqual(pos.x(), 1);
        assert.strictEqual(pos.y(), 2);
        assert.strictEqual(pos.z(), 3);
        assert.strictEqual(pos.test1(), 3);
        assert.strictEqual(pos.test2(), MyGame.Example.Color.Green);
        const t = pos.test3();
        assert.strictEqual(t.a(), 5);
        assert.strictEqual(t.b(), 6);

        assert.strictEqual(monster.testType(), MyGame.Example.Any.Monster);
        const monster2 = new MyGame.Example.Monster();
        assert.strictEqual(monster.test(monster2) != null, true);
        assert.strictEqual(monster2.name(), "Fred");

        assert.strictEqual(monster.inventoryLength(), 5);
        let invsum = 0;
        for (let i = 0; i < monster.inventoryLength(); i++) {
            invsum += monster.inventory(i);
        }
        assert.strictEqual(invsum, 10);

        let invsum2 = 0;
        const invArr = monster.inventoryArray();
        for (let i = 0; i < invArr.length; i++) {
            invsum2 += invArr[i];
        }
        assert.strictEqual(invsum2, 10);

        const test_0 = monster.test4(0);
        const test_1 = monster.test4(1);
        assert.strictEqual(monster.test4Length(), 2);
        assert.strictEqual(test_0.a() + test_0.b() + test_1.a() + test_1.b(), 100);

        assert.strictEqual(monster.testarrayofstringLength(), 2);
        assert.strictEqual(monster.testarrayofstring(0), "test1");
        assert.strictEqual(monster.testarrayofstring(1), "test2");

        assert.strictEqual(monster.testbool(), true);
    }

    function test64bit() {
        const fbb = new flatbuffers.Builder();
        const required = fbb.createString("required");

        MyGame.Example.Stat.startStat(fbb);
        const stat2 = MyGame.Example.Stat.endStat(fbb);

        MyGame.Example.Monster.startMonster(fbb);
        MyGame.Example.Monster.addName(fbb, required);
        MyGame.Example.Monster.addTestempty(fbb, stat2);
        var mon2 = MyGame.Example.Monster.endMonster(fbb);

        MyGame.Example.Stat.startStat(fbb);
        // 2541551405100253985 = 0x87654321(low part) + 0x23456789 * 0x100000000(high part);
        MyGame.Example.Stat.addVal(fbb, new flatbuffers.Long(0x87654321, 0x23456789)); // the low part is Uint32
        var stat = MyGame.Example.Stat.endStat(fbb);

        MyGame.Example.Monster.startMonster(fbb);
        MyGame.Example.Monster.addName(fbb, required);
        MyGame.Example.Monster.addEnemy(fbb, mon2);
        MyGame.Example.Monster.addTestempty(fbb, stat);
        var mon = MyGame.Example.Monster.endMonster(fbb);

        MyGame.Example.Monster.finishMonsterBuffer(fbb, mon);
        const bytes = fbb.asUint8Array();

        ////////////////////////////////////////////////////////////////

        const bb = new flatbuffers.ByteBuffer(bytes);
        assert.ok(MyGame.Example.Monster.bufferHasIdentifier(bb));
        var mon = MyGame.Example.Monster.getRootAsMonster(bb);

        var stat = mon.testempty();
        assert.strictEqual(stat != null, true);
        assert.strictEqual(stat.val() != null, true);
        assert.strictEqual(stat.val().toFloat64(), 2541551405100253985);

        var mon2 = mon.enemy();
        assert.strictEqual(mon2 != null, true);
        stat = mon2.testempty();
        assert.strictEqual(stat != null, true);
        assert.strictEqual(stat.val() != null, true);
        assert.strictEqual(stat.val().low, 0); // default value
        assert.strictEqual(stat.val().high, 0);
    }

    function testUnicode() {
        const unicode_json = sysPath.join(workDir, "unicode_test.json");
        const json_contents = fs.readFileSync(unicode_json);

        const correct = addon.binary({
            schema,
            schema_contents,
            schema_length: schema_contents.length,
            json: unicode_json,
            json_contents,
            json_length: json_contents.length,
            include_directories,
        // size_prefixed: true,
        });

        const json = JSON.parse(json_contents);

        // Test reading
        function testReadingUnicode(bb) {
            const monster = MyGame.Example.Monster.getRootAsMonster(bb);
            assert.strictEqual(monster.name(), json.name);
            assert.deepEqual(Buffer.from(monster.name(flatbuffers.Encoding.UTF8_BYTES)), Buffer.from(json.name));
            assert.strictEqual(monster.testarrayoftablesLength(), json.testarrayoftables.length);
            json.testarrayoftables.forEach((table, i) => {
                const value = monster.testarrayoftables(i);
                assert.strictEqual(value.name(), table.name);
                assert.deepEqual(Buffer.from(value.name(flatbuffers.Encoding.UTF8_BYTES)), Buffer.from(table.name));
            });
            assert.strictEqual(monster.testarrayofstringLength(), json.testarrayofstring.length);
            json.testarrayofstring.forEach((string, i) => {
                assert.strictEqual(monster.testarrayofstring(i), string);
                assert.deepEqual(Buffer.from(monster.testarrayofstring(i, flatbuffers.Encoding.UTF8_BYTES)), Buffer.from(string));
            });
        }
        testReadingUnicode(new flatbuffers.ByteBuffer(new Uint8Array(correct)));

        // Test writing
        const fbb = new flatbuffers.Builder();
        const name = fbb.createString(json.name);
        const testarrayoftablesOffsets = json.testarrayoftables.map(table => {
            const name = fbb.createString(new Uint8Array(Buffer.from(table.name)));
            MyGame.Example.Monster.startMonster(fbb);
            MyGame.Example.Monster.addName(fbb, name);
            return MyGame.Example.Monster.endMonster(fbb);
        });
        const testarrayoftablesOffset = MyGame.Example.Monster.createTestarrayoftablesVector(fbb,
            testarrayoftablesOffsets);
        const testarrayofstringOffset = MyGame.Example.Monster.createTestarrayofstringVector(fbb,
            json.testarrayofstring.map(string => {
                return fbb.createString(string);
            }));
        MyGame.Example.Monster.startMonster(fbb);
        MyGame.Example.Monster.addTestarrayofstring(fbb, testarrayofstringOffset);
        MyGame.Example.Monster.addTestarrayoftables(fbb, testarrayoftablesOffset);
        MyGame.Example.Monster.addName(fbb, name);
        MyGame.Example.Monster.finishMonsterBuffer(fbb, MyGame.Example.Monster.endMonster(fbb));
        testReadingUnicode(new flatbuffers.ByteBuffer(fbb.asUint8Array()));
    }

    const __imul = Math.imul ? Math.imul : function(a, b) {
        const ah = a >> 16 & 65535;
        const bh = b >> 16 & 65535;
        const al = a & 65535;
        const bl = b & 65535;
        return al * bl + (ah * bl + al * bh << 16) | 0;
    };

    // Include simple random number generator to ensure results will be the
    // same cross platform.
    // http://en.wikipedia.org/wiki/Park%E2%80%93Miller_random_number_generator
    let lcg_seed = 48271;

    function lcg_rand() {
        return lcg_seed = (__imul(lcg_seed, 279470273) >>> 0) % 4294967291;
    }

    function lcg_reset() {
        lcg_seed = 48271;
    }

    // Converts a Field ID to a virtual table offset.
    function fieldIndexToOffset(field_id) {
        // Should correspond to what EndTable() below builds up.
        const fixed_fields = 2; // Vtable size and Object Size.
        return (field_id + fixed_fields) * 2;
    }

    // Low level stress/fuzz test: serialize/deserialize a variety of
    // different kinds of data in different combinations
    function fuzzTest1() {
        // Values we're testing against: chosen to ensure no bits get chopped
        // off anywhere, and also be different from eachother.
        const bool_val = true;
        const char_val = -127; // 0x81
        const uchar_val = 0xFF;
        const short_val = -32222; // 0x8222;
        const ushort_val = 0xFEEE;
        const int_val = 0x83333333 | 0;
        const uint_val = 0xFDDDDDDD;
        const long_val = new flatbuffers.Long(0x44444444, 0x84444444);
        const ulong_val = new flatbuffers.Long(0xCCCCCCCC, 0xFCCCCCCC);
        const float_val = new Float32Array([3.14159])[0];
        const double_val = 3.14159265359;

        const test_values_max = 11;
        const fields_per_object = 4;
        const num_fuzz_objects = 10000; // The higher, the more thorough :)

        const builder = new flatbuffers.Builder();

        lcg_reset(); // Keep it deterministic.

        const objects = [];

        // Generate num_fuzz_objects random objects each consisting of
        // fields_per_object fields, each of a random type.
        for (let i = 0; i < num_fuzz_objects; i++) {
            builder.startObject(fields_per_object);
            for (let f = 0; f < fields_per_object; f++) {
                const choice = lcg_rand() % test_values_max;
                switch (choice) {
                    case 0: builder.addFieldInt8(f, bool_val, 0); break;
                    case 1: builder.addFieldInt8(f, char_val, 0); break;
                    case 2: builder.addFieldInt8(f, uchar_val, 0); break;
                    case 3: builder.addFieldInt16(f, short_val, 0); break;
                    case 4: builder.addFieldInt16(f, ushort_val, 0); break;
                    case 5: builder.addFieldInt32(f, int_val, 0); break;
                    case 6: builder.addFieldInt32(f, uint_val, 0); break;
                    case 7: builder.addFieldInt64(f, long_val, flatbuffers.Long.ZERO); break;
                    case 8: builder.addFieldInt64(f, ulong_val, flatbuffers.Long.ZERO); break;
                    case 9: builder.addFieldFloat32(f, float_val, 0); break;
                    case 10: builder.addFieldFloat64(f, double_val, 0); break;
                }
            }
            objects.push(builder.endObject());
        }
        builder.prep(8, 0); // Align whole buffer.

        lcg_reset(); // Reset.

        builder.finish(objects[objects.length - 1]);
        const bytes = new Uint8Array(builder.asUint8Array());
        const view = new DataView(bytes.buffer);

        // Test that all objects we generated are readable and return the
        // expected values. We generate random objects in the same order
        // so this is deterministic.
        for (let i = 0; i < num_fuzz_objects; i++) {
            const offset = bytes.length - objects[i];
            for (let f = 0; f < fields_per_object; f++) {
                const choice = lcg_rand() % test_values_max;
                const vtable_offset = fieldIndexToOffset(f);
                const vtable = offset - view.getInt32(offset, true);
                assert.ok(vtable_offset < view.getInt16(vtable, true));
                const field_offset = offset + view.getInt16(vtable + vtable_offset, true);
                switch (choice) {
                    case 0: assert.strictEqual(!!view.getInt8(field_offset), bool_val); break;
                    case 1: assert.strictEqual(view.getInt8(field_offset), char_val); break;
                    case 2: assert.strictEqual(view.getUint8(field_offset), uchar_val); break;
                    case 3: assert.strictEqual(view.getInt16(field_offset, true), short_val); break;
                    case 4: assert.strictEqual(view.getUint16(field_offset, true), ushort_val); break;
                    case 5: assert.strictEqual(view.getInt32(field_offset, true), int_val); break;
                    case 6: assert.strictEqual(view.getUint32(field_offset, true), uint_val); break;
                    case 7: assert.strictEqual(view.getInt32(field_offset, true), long_val.low); assert.strictEqual(view.getInt32(field_offset + 4, true), long_val.high); break;
                    case 8: assert.strictEqual(view.getInt32(field_offset, true), ulong_val.low); assert.strictEqual(view.getInt32(field_offset + 4, true), ulong_val.high); break;
                    case 9: assert.strictEqual(view.getFloat32(field_offset, true), float_val); break;
                    case 10: assert.strictEqual(view.getFloat64(field_offset, true), double_val); break;
                }
            }
        }
    }
});
